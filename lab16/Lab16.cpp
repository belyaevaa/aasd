#include <vector> 
#include <iostream>

//Есть рюкзак вместимостью W и n предметов, каждый из которых характеризуется ценностью p(i) и весом w(i)
//Необходимо выбрать несколько предметов так, чтобы их суммарная ценность была максимальна, а суммарный вес не превышал W.

//разбиваем задачу на подзадачи. Подзадачей в нашем случае будет являться нахождение максимальной стоимости i предметов при максимальном j весе.
//Пусть C[i][j] - максимальная суммарная стоимость, которую можно набрать первыми i предметами так, чтобы их вес не превосходил j.
//При заполнении таблицы мы рассматриваем, выгодно ли вообще добавлять еще один предмет в рюкзак так, чтобы суммарный вес предметов был равен j. 

//решение исходной задачи будет являться значение таблицы C[n][W]


int backpack(std::vector<std::pair<int, int>>& stuff, int W) // Решение задачи, деля ее на маленькие подзадачи, формально, создается дискретная таблица значений
{                                                           // (двумерный массив dp) где снизу справа самый лучший исход
    int  n = stuff.size();
    std::vector<std::vector<int>> dp(W + 1, std::vector<int>(n + 1, 0));

    for (int j = 1; j <= n; j++)
    {
        for (int w = 1; w <= W; w++)
        {
            int weigth = stuff[j - 1].second;
            if (weigth <= w)
            {
                int price = stuff[j - 1].first;
                dp[w][j] = std::max(dp[w][j - 1], dp[w - weigth][j - 1] + price); // выбор более выгодного случая 
            }                                                                     //либо ложим элемент и уменьшается его вес или оставляем прежний вес но не увеличивается стоимость
            else
            {
                dp[w][j] = dp[w][j - 1];
            }
        }
    }
    return dp[W][n];
}



void main()
{
    std::vector<std::pair<int, int>> stuff = { {1,3},{6,4}, {4,5}, {7,8}, {6,9} }; // Здесь пары предметов (стоимость, вес)
    int w = 13; // Грузоподъемность рюкзака
    std::cout << backpack(stuff, w) << std::endl;
}